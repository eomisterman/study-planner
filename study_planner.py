#!/usr/bin/env python3
"""
Study Planner - Transform video course outlines into balanced study schedules.

A command-line tool that takes JSON course outlines and generates Markdown
study schedules with progress tracking checkboxes.
"""

import argparse
import json
import sys
import re
from datetime import datetime, timedelta


def validate_start_date(date_string):
    """Parse and validate start date with auto-correction for weekends."""
    print(f"   📅 Validating start date: {date_string}")
    
    # Check basic format first
    date_pattern = r'^\d{4}-\d{2}-\d{2}$'
    if not re.match(date_pattern, date_string):
        print(f"   ❌ Error: Invalid date format: {date_string}")
        print("   Please use YYYY-MM-DD format (e.g., 2024-01-15)")
        sys.exit(1)
    
    # Parse the date
    try:
        parsed_date = datetime.strptime(date_string, '%Y-%m-%d').date()
    except ValueError as e:
        print(f"   ❌ Error: Invalid date: {date_string}")
        print("   Please check that the month (01-12) and day are valid.")
        print("   Example: 2024-01-15 (January 15, 2024)")
        sys.exit(1)
    
    # Check if date is in the past
    today = datetime.now().date()
    if parsed_date < today:
        print(f"   ❌ Error: Start date cannot be in the past: {date_string}")
        print(f"   Today is {today.strftime('%Y-%m-%d')}")
        print("   Please choose today's date or a future date.")
        sys.exit(1)
    
    # Auto-correct weekend dates to following Monday
    weekday = parsed_date.weekday()  # Monday = 0, Sunday = 6
    if weekday == 5:  # Saturday
        corrected_date = parsed_date + timedelta(days=2)
        print(f"   📅 Weekend date detected: {date_string} is a Saturday")
        print(f"   🔄 Auto-corrected to following Monday: {corrected_date.strftime('%Y-%m-%d')}")
        return corrected_date
    elif weekday == 6:  # Sunday
        corrected_date = parsed_date + timedelta(days=1)
        print(f"   📅 Weekend date detected: {date_string} is a Sunday")
        print(f"   🔄 Auto-corrected to following Monday: {corrected_date.strftime('%Y-%m-%d')}")
        return corrected_date
    else:
        # Weekday - use as-is
        weekday_name = parsed_date.strftime('%A')
        print(f"   ✅ Valid weekday: {date_string} ({weekday_name})")
        return parsed_date


def parse_course_json(input_file):
    """Parse and validate JSON course file."""
    print(f"📖 Parsing course file: {input_file}")
    try:
        # TODO: Implement full JSON parsing and validation in Phase 2
        # For now, return placeholder data to test pipeline
        return {
            "course_title": "Sample Course",
            "sections": []
        }
    except Exception as e:
        print(f"❌ Error parsing course file: {e}")
        raise


def schedule_course(course_data, daily_limit, start_date):
    """Generate balanced study schedule from course data."""
    print(f"📅 Scheduling course: {course_data['course_title']}")
    print(f"   Daily limit: {daily_limit} minutes")
    print(f"   Start date: {start_date}")
    try:
        # TODO: Implement core scheduling algorithm in Phase 3
        # For now, return placeholder scheduled days
        return [
            {
                "day": 1,
                "date": start_date,
                "items": [],
                "total_minutes": 0
            }
        ]
    except Exception as e:
        print(f"❌ Error scheduling course: {e}")
        raise


def generate_markdown(scheduled_days):
    """Generate Markdown output with checkboxes."""
    print(f"📝 Generating Markdown for {len(scheduled_days)} days")
    try:
        # TODO: Implement Markdown generation in Phase 4
        # For now, return placeholder markdown
        return "# Study Schedule\n\n*Generated by Study Planner*"
    except Exception as e:
        print(f"❌ Error generating Markdown: {e}")
        raise


def write_output(markdown_content, output_filename):
    """Write Markdown content to file."""
    print(f"💾 Writing output to: {output_filename}")
    try:
        # TODO: Implement file output in Phase 4
        # For now, just show what would be written
        print("Preview of output:")
        print("-" * 40)
        print(markdown_content)
        print("-" * 40)
        print(f"✅ Would write to: {output_filename}")
    except Exception as e:
        print(f"❌ Error writing output: {e}")
        raise


def main():
    """Main pipeline function."""
    # Set up command-line argument parsing
    parser = argparse.ArgumentParser(
        description="Transform video course outlines into balanced study schedules.",
        epilog="""
Examples:
  python study_planner.py sample_course.json 60 2024-01-15
    Generate a schedule with 60 minutes per day starting January 15, 2024
    
  python study_planner.py aws_course.json 90 2024-02-01
    Generate a schedule with 90 minutes per day starting February 1, 2024
    
  python study_planner.py course.json 120 2024-03-15
    Generate a schedule with 2 hours per day starting March 15, 2024

Output:
  Creates a Markdown file with checkboxes for progress tracking
  Schedule includes only weekdays (Monday-Friday)
  Content is balanced across days respecting your time limits
        """,
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    
    parser.add_argument(
        "course_file",
        help="JSON file containing course outline with sections and items"
    )
    
    parser.add_argument(
        "daily_minutes", 
        type=int,
        help="Maximum study time per day (minimum: 20 minutes, maximum: 480 minutes)"
    )
    
    parser.add_argument(
        "start_date",
        help="Start date in YYYY-MM-DD format (if weekend, will start following Monday)"
    )
    
    # Parse arguments
    try:
        args = parser.parse_args()
    except SystemExit:
        return
    
    # Extract arguments for pipeline
    input_file = args.course_file
    daily_limit = args.daily_minutes
    start_date = args.start_date
    
    # Basic argument validation
    print("🔍 Validating arguments...")
    
    # Check if course file exists and is readable
    try:
        with open(input_file, 'r') as f:
            pass  # Just check if we can open it
        print(f"   ✅ Course file found: {input_file}")
    except FileNotFoundError:
        print(f"   ❌ Error: Course file not found: {input_file}")
        print("   Make sure the file exists and the path is correct.")
        sys.exit(1)
    except PermissionError:
        print(f"   ❌ Error: Cannot read course file: {input_file}")
        print("   Check file permissions.")
        sys.exit(1)
    
    # Basic sanity check on daily_minutes
    if daily_limit <= 0:
        print(f"   ❌ Error: Daily minutes must be positive, got: {daily_limit}")
        print("   Please specify a positive number of minutes.")
        sys.exit(1)
    print(f"   ✅ Daily limit: {daily_limit} minutes")
    
    # Comprehensive date validation with auto-correction
    validated_start_date = validate_start_date(start_date)
    
    print("   🎯 All validation passed!")
    print()
    
    print(f"Study Planner")
    print(f"Course File: {input_file}")
    print(f"Daily Limit: {daily_limit} minutes")
    print(f"Start Date: {validated_start_date}")
    print()
    
    try:
        # Execute the full pipeline
        print("🚀 Starting pipeline...")
        
        # Phase 1: Parse course data
        course_data = parse_course_json(input_file)
        
        # Phase 2: Generate schedule
        scheduled_days = schedule_course(course_data, daily_limit, validated_start_date)
        
        # Phase 3: Generate Markdown
        markdown = generate_markdown(scheduled_days)
        
        # Phase 4: Write output file
        output_filename = f"{course_data['course_title'].lower().replace(' ', '_')}_schedule.md"
        write_output(markdown, output_filename)
        
        print()
        print("✅ Pipeline completed successfully!")
        print("Ready for Phase 2 implementation: Input Validation & Parsing")
        
    except Exception as e:
        print()
        print(f"💥 Pipeline failed: {e}")
        print("Check the error above and try again.")
        sys.exit(1)


if __name__ == "__main__":
    main()